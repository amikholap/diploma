\section{Описание разработанных алгоритмов}
\label{sec:practice}


\subsection{Введение}

В предыдущей главе было рассказано об основных способах представления сигнала и базовых алгоритмах для работы с ним. Правильный подбор инструментов анализа играет решающую роль в успешном достижении цели. При обработке данных правильным образом сами собой становятся заметны особенности и закономерности, стоящие за ними. Тогда для принятия решения оказывается достаточно применения простых методов математической статистики.

В случае обнаружения сигналов ключевую роль играет частотно-временное представление. Оно сохраняет хронологию спектра, тем самым открывая для исследования изменение состава сигнала во времени. Оконное преобразование Фурье использовалось как предваряющий этап всех применяемых методов.

В общей постановке задача обнаружения сигналов очень сложна. Существует множество их типов и разновидностей помех. Можно назвать несколько важных характеристик, которые должен учитывать алгоритм: ширина полосы частот, модуляция, прерывается ли сигнал. Причем каждая их комбинация имеет право на жизнь. Пытаться покрыть все случаи сразу трудно и неэффективно. Разумнее разбить задачу на независимые части и решать их по отдельности.

Реальный тип сигнала всегда является причиной постановки новой подзадачи обнаружения. Не имеет смысла пытаться придумать решение абстрактной проблемы, ведь потом его придется исправлять под практические нужды. Каждый описанный алгоритм использует специфику встречающегося в эфире сигнала. Конечно, они могут сработать и с похожими на него, но изначально это не планировалось. Покрытие частных случаев может показаться слишком узкоспециализированным решением, но оно оправдывает себя. Во первых, большинство сигналов однотипны и для хорошего покрытия не требуется много алгоритмов. Во вторых, даже если удастся найти неопознанный сигнал, то возникает проблема его идентификации. Он может оказаться обычным шумом, каким-то образом прошедшим фильтрацию. А если это и не шум, то непонятно как извлечь из него информацию. В третьих, работа с частными случаями значительно упрощает алгоритмы и повышает доверие к ним. В четвертых, всегда можно добавить обобщенный обнаружитель, который будет иметь менее строгую фильтрацию. Его всегда можно использовать как запасной вариант.


\subsection{Архитектура}

Разработанный программный продукт представляет собой приложение для персонального компьютера, считывающее данные из заданного источника и выводящее на экран тип и полосу частот обнаруженных сигналов. Для взаимодействия с пользователем предусмотрен интерфейс командной строки. Реализация диктовалась требованиями, поставленными к конечному продукту. Вот основные из них:

\begin{itemize}
  \item{Способность считывать данные из различных источников (файл, радиоприемник и другие);}
  \item{Поддержка наиболее распространенных типов сигналов с возможностью добавлять новые;}
  \item{Работа в реальном времени;}
  \item{Оповещение о найденном сигнале с минимальной задержкой;}
  \item{Постоянный объем используемой памяти во времени.}
\end{itemize}

Возможность подменять источник данных оказывается очень полезной как при использовании, так и при разработке. Основным, конечно, является \SDR-приемник. Во время активности он непрерывно передает комплексные значения сигнала. Их нужно обработать как можно быстрее, чтобы успевать за потоком. Также эти значения можно сохранять в файл для последующего анализа. Поэтому нужен режим чтения из файла. В нем важно соблюдать ограничение по памяти --- комплексные семплы частотой более двух миллионов в секунду быстро образуют гигабайты информации. Обработать такой файл за один раз не получится. Помимо этих двух источников, предоставляющих реальные данные, для определения характеристик обнаружителя полезно проверять его на модельных сигналах. Они представляют собой функции уровня волны от времени и работают как на отдельных значениях, так и на их последовательности.

Очевидно, что столь разнородные источники стоит объединить общим интерфейсом. Им стал абстрактный \textbf{поставщик данных}. Его задача --- унификация доступа к данным, то есть определение эталонного образа делать это.

Предпочтительным оказался пакетный режим поставки. Он позволяет производить более эффективные операции над блоками данных и его можно реализовать во всех предполагаемых источниках. По команде "<старт"> поставщик начинает считывать данные, группировать их в блоки и при достижении заданного размера блока отправлять событие об его готовности. По команде "<стоп"> он досылает оставшиеся данные и прекращает свою работу.

Важно отметить использование событийной модели. Она обеспечивает слабую связность между компонентами системы. Заинтересованная сторона просто подписывается на событие поставщика. Она предоставляет функцию, которая выполнится, когда событие произойдет. Не требуется полагаться на детали реализации --- знать когда и откуда брать данные. Поставщику же не нужно следить, кому он должен их передать. Две стороны работают независимо, имея единственную точку соприкосновения. Это помогает и при отладке, когда можно легко вклиниться в цепочку обработки сигнала, не прерывая основной процесс.

В общем случае считывание данных из источника может быть блокирующей операцией. Это значит, что основной процесс приложения на это время полностью останавливается. Такое поведение значительно ухудшает общую производительность системы, поэтому считывание было вынесено в отдельный поток. Он запускается при старте поставщика данных, а при его остановке присоединяется к основному потоку.

Была упомянута польза работы с модельными данными. Реальные сигналы очень разнообразны, но над ними нет контроля --- можно экспериментировать только над теми, которые были вручную найдены и сохранены. Часто возникает желание проверить алгоритм на несколько модифицированном сигнале, чтобы убедиться в его обобщающей способности и узнать границы эффективного распознавания. В этом очень помогают математические модели. Любой сигнал в любой среде можно сымитировать. Конечно, эта имитация идеализирует реальные условия, но в целом достаточно хороша для исследовательских целей. Для решения этой задачи был реализован \textbf{микрофреймворк моделирования сигналов}.

Прежде всего он содержит примитивы, служащие строительными блоками для построения более сложных конструкций. К ним относятся волна с заданной амплитудой, частотой и начальной фазой и шум как случайный процесс с изменяемыми параметрами распределения. Далее возникает потребность комбинировать блоки. Это можно делать с помощью взвешенной суммы и поточечного умножения. Комбинация волн и шума дает различные по составу сигналы с аддитивными и мультипликативными помехами. Следующим шагом были реализованы основные методы модуляции. В совокупности с их помощью можно создавать сигналы близкие к реальным. Например, чтобы смоделировать зашумленный FM сигнал, содержащий синусоиду, нужно создать волну, FM-промодулировать ее и добавить аддитивный шум. Видны три ключевых шага: образование сигнала, представляющего полезную информацию, модуляция и добавление шума. Каждый из них можно модифицировать независимо от других, получая всевозможные виды сигналов.

API микрофреймворка моделирования сигналов представляет собой набор функций-конструкторов, реализующих описанные примитивы. Каждая из них возвращает функцию-замыкание, хранящую параметры модели. Их можно условно разделить на два типа: генераторы и комбинаторы. Генераторы оперируют над целыми числами, обозначающие моменты времени, либо над их массивами и возвращают комплексные значения уровня сигнала в это время. Комбинаторы принимают на вход один или более генераторов и, возможно, дополнительные параметры и возвращают новый генератор, являющийся продуктом объединения исходных.

Ниже приведен простейший пример моделирования синусоиды единичной амплитуды и частоты \SI{3.4}{\kilo\hertz}, FM-модулированной на несущей единичной амплитуды частотой \SI{80}{\mega\hertz}, с аддитивными помехами, представленными нормально распределенной случайной величиной с среднеквадратичным отклонением \num{0.5} (\autoref{lst:practice:modelling_example}).

\begin{listing}
  \begin{minted}{python}
    w = wave(A=1, f=3.4e3)
    nfm = fm(w, carrier_amp=1, carrier_freq=80e6, deviation=5)
    n = noise(std=0.5)
    noised_nfm = add(nfm, n)

    time = np.linspace(0, 1, 1000)
    signal = noised_nfm(time)
  \end{minted}
  \caption{Моделирование узкополосного FM сигнала}
  \label{lst:practice:modelling_example}
\end{listing}

Поставщик данных, работающий с моделями очень прост. При старте он инициализирует таймер нулевым значением, а затем "засыпает" на некоторое время. При следующей активации он рассчитывает, сколько прошло времени с последней активации, обновляет таймер и генерирует блок модельных данных за прошедший период времени с заданной частотой дискретизации.

Следующим звеном в цепи обработки сигнала является \textbf{сканер}. Его задача агрегировать поступающие данные, проводить их предобработку, отправлять на анализ и доводить до пользователя его результаты. Он работает на довольно абстрактном уровне, "склеивая" остальные части системы.

Для работы ему необходим поставщик данных, анализаторы и модуль ввода-вывода. Он подписывается на события, подаваемые поставщиком и накапливает приходящие данные. Когда их становится достаточно много, сканер выполняет над ними оконное преобразование Фурье и сохраняет его результаты в круговой буфер. Последний необходим из-за ограничения по памяти. Семплы приходят в очень большом объеме и хранить их все в памяти невозможно. Пару минут записи могут стать гигабайтами информации при большой частоте дискретизации. Поэтому приходится ограничиваться окном в несколько десятков секунд.

Таким образом, сканер всегда имеет частотно-временное представление сигнала в ближайшем временном интервале. При его обновлении инициируется событие, на которое подписаны анализаторы. Событийная модель предоставляет уже описанные преимущества --- слабая связность модулей и удобство отладки.

Для сканера анализаторы представляют собой "черные ящики". Он только инициирует событие и смотрит на результаты его обработки. Результаты --- это списки полос частот (возможно пустые), на которых анализаторы обнаружили сигнал. У сканера есть таблица частот, на которых уже были срабатывания. Он сопоставляет новые списки частот с этой таблицей и инициирует событие, на которое подписан модуль ввода-вывода. Он обновляет информацию на экране. Так текущее состояние системы отображается пользователю.

\textbf{Модуль ввода-вывода} очень прост. Он ожидает события сканера об обновлении списка частот и отображает его на экран. Возможно подменить модуль, работающий со стандартным потоком вывода в интерактивном режиме на модуль, пишущий в файл. Этот режим может быть использован для составления списка каналов, работающих в исследуемой полосе частот.

\textbf{Анализаторы} --- это основная рабочая сила приложения. Их задача принимать решения, на каких частотах наблюдаются нешумовые сигналы. Как было сказано, общую задачу обнаружения сигналов можно свести к набору частных задач обнаружения отдельных их типов. Поэтому для каждого поддерживаемого типа существует свой анализатор, который применяет специфичные алгоритмы.

Все анализаторы работают с частотно-временным представлением сигнала, но дальнейшая его обработка может сильно различаться. Они принимают на вход временное окно значений спектра и возвращают список частот обнаруженных сигналов. Такой общий интерфейс дает возможность применять их не завися от реализации.

Основной сценарий их использования --- обработка данных от радиоприемника в реальном времени. Это накладывает ограничения на вычислительную сложность используемых алгоритмов. Программное средство написано на языке \python, который не оптимален для тяжелых вычислений. На помощью приходит библиотека numpy, реализованная на языке \purec и интегрированная в \python как модуль. Она предоставляет средства для эффективных операций на матрицах, чем и являются частотно-временные представления сигнала. Распараллеливанием вычислений и использованием возможностей процессора по работе с гомогенными блоками данных, numpy удается достичь нескольких порядков прироста производительности в сравнении с чистым \python.

Для дальнейшей оптимизации можно применять различные эвристики. Например, скорость поступления новых данных зачастую избыточна для успешного обнаружения. Данные могут обновляться много раз в секунду. Такая детализация, конечно, повышает оперативность срабатывания обнаружителя, но практически не увеличивает достоверности его работы. Установка предельной частоты вызова анализаторов может повысить производительность практически без потерь эффективности.
